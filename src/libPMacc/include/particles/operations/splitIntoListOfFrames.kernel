/**
 * Copyright 2014-2016 Rene Widera, Alexander Grund
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */


#pragma once

#include "pmacc_types.hpp"
#include "dimensions/DataSpaceOperations.hpp"
#include "math/Vector.hpp"
#include "particles/frame_types.hpp"
#include "nvidia/atomic.hpp"

namespace PMacc
{
namespace particles
{
namespace operations
{

/** Copy particles from big frame to PMacc frame structure
 *  (Opposite to ConcatListOfFrames)
 *
 * - convert globalCellIdx to localCellIdx
 * - processed particles per block <= number of cells per superCell
 *
 * @param counter box with three integer [srcParticleOffset, numLoadedParticles, numUsedFrames]
 * @param destBox particle box were all particles are copied to (destination)
 * @param srcFrame frame with particles (is used as source)
 * @param maxParticles number of particles in srcFrame
 * @param localDomainCellOffset offset in cells to global origin (@see wiki PIConGPU domain definitions)
 * @param cellDesc picongpu cellDescription
 */
template<class T_CounterBox, class T_DestBox, class T_SrcFrame, class T_Space, class T_CellDescription>
__global__ void splitIntoListOfFrames(T_CounterBox counter, T_DestBox destBox, T_SrcFrame srcFrame,
                                        const int maxParticles,
                                        T_Space localDomainCellOffset, T_CellDescription cellDesc)
{
    using namespace PMacc::particles::operations;

    typedef T_SrcFrame SrcFrameType;
    typedef typename T_DestBox::FrameType DestFrameType;
    typedef typename T_DestBox::FramePtr DestFramePtr;
    typedef typename T_CellDescription::SuperCellSize SuperCellSize;
    BOOST_CONSTEXPR_OR_CONST unsigned NumDims = T_DestBox::Dim;
    const uint32_t particlesPerFrame = PMacc::math::CT::volume<SuperCellSize>::type::value;

    __shared__ typename PMacc::traits::GetEmptyDefaultConstructibleType<DestFramePtr>::type destFramePtr[particlesPerFrame];
    __shared__ int linearSuperCellIds[particlesPerFrame];
    __shared__ int srcParticleOffset;


    const int linearThreadIdx = threadIdx.x;


    const DataSpace<NumDims> numSuperCells(cellDesc.getGridSuperCells() - cellDesc.getGuardingSuperCells()*2);
    if (linearThreadIdx == 0)
    {
        /* apply for work for the full block
         * counter [0] -> offset to load particles
         */
        srcParticleOffset = atomicAdd(&(counter[0]), particlesPerFrame);
    }
    destFramePtr[linearThreadIdx] = DestFramePtr();
    linearSuperCellIds[linearThreadIdx] = -1;

    __syncthreads();

    const int srcParticleIdx = srcParticleOffset + linearThreadIdx;
    const bool hasValidParticle = srcParticleIdx < maxParticles;
    DataSpace<NumDims> superCellIdx;
    lcellId_t lCellIdx = INV_LOC_IDX;
    int myLinearSuperCellId = -1;

    if (hasValidParticle)
    {
        const DataSpace<NumDims> globalCellIdx = srcFrame[srcParticleIdx][globalCellIdx_]
                                                 - localDomainCellOffset;
        superCellIdx = globalCellIdx / SuperCellSize::toRT();
        myLinearSuperCellId = DataSpaceOperations<NumDims>::map(numSuperCells, superCellIdx);
        linearSuperCellIds[linearThreadIdx] = myLinearSuperCellId;
        DataSpace<NumDims> localCellIdx(globalCellIdx - superCellIdx * SuperCellSize::toRT());
        lCellIdx = DataSpaceOperations<NumDims>::template map<SuperCellSize>(localCellIdx);
    }
    __syncthreads();

    int masterIdx = linearThreadIdx - 1;

    if (hasValidParticle)
    {
        /* search master thread index */
        while (masterIdx >= 0)
        {
            if (myLinearSuperCellId != linearSuperCellIds[masterIdx])
                break;
            --masterIdx;
        }
        ++masterIdx;
        /* load empty frame if thread is the master*/
        if (masterIdx == linearThreadIdx)
        {
            /* counter[2] -> number of used frames */
            nvidia::atomicAllInc(&(counter[2]));
            DestFramePtr tmpFrame = destBox.getEmptyFrame();
            destFramePtr[linearThreadIdx] = tmpFrame;
            destBox.setAsFirstFrame(tmpFrame, superCellIdx + cellDesc.getGuardingSuperCells());
        }
    }
    __syncthreads();

    if (hasValidParticle)
    {
        /* copy attributes and activate particle*/
        PMACC_AUTO(parDest, destFramePtr[masterIdx][linearThreadIdx]);
        PMACC_AUTO(parDestDeselect, deselect<bmpl::vector2<localCellIdx, multiMask> >(parDest));
        assign(parDestDeselect, srcFrame[srcParticleIdx]);
        parDest[localCellIdx_] = lCellIdx;
        parDest[multiMask_] = 1;
        /* counter[1] -> number of loaded particles
         * this counter is evaluated on host side
         * (check that loaded particles by this kernel == loaded particles from HDF5 file)*/
        nvidia::atomicAllInc(&(counter[1]));
    }
}

} //namespace operations
} //namespace particles
} //namespace PMacc
